<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MAXene Material Viewer</title>
  <script src="https://3Dmol.csb.pitt.edu/build/3Dmol-min.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
      max-width: 960px;
      margin: auto;
      padding: 1rem;
      line-height: 1.6;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    .container {
      background: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
    }
    h1, h2 {
      color: #2c3e50;
      border-bottom: 2px solid #3498db;
      padding-bottom: 8px;
      margin-bottom: 1rem;
    }
    h1 {
      text-align: center;
      font-size: 2.5rem;
      background: linear-gradient(45deg, #3498db, #2c3e50);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .structure, .phonon {
      margin-top: 2rem;
    }
    #viewer {
      width: 100%;
      height: 450px;
      border: 2px solid #3498db;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    #phononPlot {
      width: 100%;
      height: 450px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .info-table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 1rem;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .info-table th, .info-table td {
      border: none;
      padding: 12px 16px;
      text-align: left;
    }
    .info-table th {
      background: linear-gradient(45deg, #3498db, #2980b9);
      color: white;
      font-weight: 600;
    }
    .info-table tr:nth-child(even) {
      background-color: #f8f9fa;
    }
    .info-table tr:hover {
      background-color: #e3f2fd;
    }
    .section {
      margin-top: 2rem;
      padding: 1rem;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #3498db;
    }
    .loading {
      text-align: center;
      padding: 2rem;
      color: #666;
      font-style: italic;
    }
    .error {
      background: #ffebee;
      color: #c62828;
      padding: 1rem;
      border-radius: 4px;
      border-left: 4px solid #f44336;
      margin: 1rem 0;
    }
    .success {
      background: #e8f5e8;
      color: #2e7d32;
      padding: 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }
  </style>
</head>
<body>
<div class="container">
  <h1>Material: Ti<sub>2</sub>C (MAXene)</h1>
  
  <div class="structure section">
    <h2>ðŸ§Š Crystal Structure</h2>
    <div id="structureStatus" class="loading">Loading crystal structure...</div>
    <div id="viewer"></div>
  </div>
  
  <div class="section">
    <h2>ðŸ§® Structural Details</h2>
    <div id="structuralStatus" class="loading">Loading structural data...</div>
    <table class="info-table" id="latticeTable" style="display:none;">
      <thead><tr><th colspan="4">Lattice Vectors (Ã…)</th></tr></thead>
      <tbody></tbody>
    </table>
    <table class="info-table" id="atomTable" style="display:none;">
      <thead><tr><th>Element</th><th>x (fractional)</th><th>y (fractional)</th><th>z (fractional)</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
  
  <div class="phonon section">
    <h2>ðŸŽµ Phonon Band Structure</h2>
    <div id="phononStatus" class="loading">Loading phonon dispersion...</div>
    <div id="phononPlot"></div>
  </div>
</div>

<script>
// Global variables to store loaded data
let structureData = null;
let phononData = null;

// Initialize 3D molecular viewer with CIF file
function load3DStructure() {
  try {
    const viewer = $3Dmol.createViewer("viewer", { 
      backgroundColor: "white",
      antialias: true 
    });
    
    // Load CIF file using fetch and then add to viewer
    fetch("POSCAR.cif")
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.text();
      })
      .then(cifData => {
        // Add the CIF data to the viewer
        viewer.addModel(cifData, "cif");
        
        // Set visualization style
        viewer.setStyle({}, {
          stick: { radius: 0.2, color: 'spectrum' },
          sphere: { scale: 0.7 }
        });
        
        // Try to color by element if possible
        viewer.setStyle({elem: 'Ti'}, {
          stick: { radius: 0.2 },
          sphere: { scale: 0.8, color: '#c0c0c0' }
        });
        
        viewer.setStyle({elem: 'C'}, {
          stick: { radius: 0.15 },
          sphere: { scale: 0.6, color: '#404040' }
        });
        
        // Zoom to fit and render
        viewer.zoomTo();
        viewer.render();
        
        document.getElementById("structureStatus").innerHTML = 
          '<div class="success">âœ“ Crystal structure loaded successfully from POSCAR.cif</div>';
        
        console.log("3D structure loaded successfully from CIF file");
      })
      .catch(error => {
        console.error("Error loading CIF file:", error);
        document.getElementById("structureStatus").innerHTML = 
          `<div class="error">Error loading POSCAR.cif: ${error.message}</div>`;
      });
      
  } catch (error) {
    console.error("Error initializing 3D viewer:", error);
    document.getElementById("structureStatus").innerHTML = 
      `<div class="error">Error initializing 3D viewer: ${error.message}</div>`;
  }
}

// Parse and display POSCAR structural data
function loadStructuralData() {
  fetch("POSCAR")
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.text();
    })
    .then(text => {
      console.log("POSCAR file loaded, parsing...");
      
      const lines = text.trim().split('\n');
      const scale = parseFloat(lines[1]);
      
      // Parse lattice vectors
      const lattice = lines.slice(2, 5).map(line => 
        line.trim().split(/\s+/).map(val => parseFloat(val) * scale)
      );
      
      // Parse element names and counts
      const elements = lines[5].trim().split(/\s+/);
      const counts = lines[6].trim().split(/\s+/).map(Number);
      
      // Determine if coordinates are Direct or Cartesian
      const coordType = lines[7].trim().toLowerCase();
      const isDirect = coordType.startsWith('d') || coordType.startsWith('direct');
      
      // Parse atomic positions
      const totalAtoms = counts.reduce((a, b) => a + b, 0);
      const positions = lines.slice(8, 8 + totalAtoms).map(line => 
        line.trim().split(/\s+/).slice(0, 3).map(Number)
      );
      
      // Store parsed data
      structureData = {
        scale: scale,
        lattice: lattice,
        elements: elements,
        counts: counts,
        positions: positions,
        isDirect: isDirect
      };
      
      // Populate lattice table
      const latticeTable = document.querySelector("#latticeTable tbody");
      latticeTable.innerHTML = '';
      lattice.forEach((vector, i) => {
        const row = `
          <tr>
            <td><strong>a${i+1}</strong></td>
            <td>${vector[0].toFixed(4)}</td>
            <td>${vector[1].toFixed(4)}</td>
            <td>${vector[2].toFixed(4)}</td>
          </tr>
        `;
        latticeTable.innerHTML += row;
      });
      
      // Populate atoms table
      const atomTable = document.querySelector("#atomTable tbody");
      atomTable.innerHTML = '';
      let atomIndex = 0;
      
      elements.forEach((element, elemIndex) => {
        for (let i = 0; i < counts[elemIndex]; i++) {
          const pos = positions[atomIndex];
          const row = `
            <tr>
              <td><strong>${element}</strong></td>
              <td>${pos[0].toFixed(6)}</td>
              <td>${pos[1].toFixed(6)}</td>
              <td>${pos[2].toFixed(6)}</td>
            </tr>
          `;
          atomTable.innerHTML += row;
          atomIndex++;
        }
      });
      
      // Show tables and update status
      document.getElementById("latticeTable").style.display = "table";
      document.getElementById("atomTable").style.display = "table";
      document.getElementById("structuralStatus").innerHTML = 
        `<div class="success">âœ“ Structural data loaded from POSCAR (${isDirect ? 'Direct' : 'Cartesian'} coordinates)</div>`;
      
      console.log("Structural data parsed successfully");
      
    })
    .catch(error => {
      console.error("Error loading POSCAR file:", error);
      document.getElementById("structuralStatus").innerHTML = 
        `<div class="error">Error loading POSCAR: ${error.message}</div>`;
    });
}

// Load and plot phonon dispersion data
function loadPhononData() {
  fetch("phonon_band.json")
    .then(response => {
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return response.json();
    })
    .then(data => {
      console.log("Phonon data loaded:", data);
      phononData = data;
      
      // Validate data structure
      if (!data.qpoints || !data.frequencies) {
        throw new Error("Invalid phonon data format - missing qpoints or frequencies");
      }
      
      // Create traces for each phonon mode
      const traces = [];
      const numModes = data.frequencies[0] ? data.frequencies[0].length : 0;
      
      if (numModes === 0) {
        throw new Error("No phonon modes found in data");
      }
      
      for (let i = 0; i < numModes; i++) {
        const frequencies = data.frequencies.map(freqArray => freqArray[i]);
        
        traces.push({
          x: data.qpoints,
          y: frequencies,
          mode: 'lines',
          line: { 
            width: 2,
            color: i < 3 ? `hsl(${200 + i*20}, 70%, 50%)` : `hsl(${0 + i*30}, 70%, 50%)`
          },
          name: `Mode ${i + 1}`,
          showlegend: false,
          hovertemplate: `Mode ${i + 1}<br>` +
                        'q-point: %{x:.3f}<br>' +
                        'Frequency: %{y:.2f} THz<extra></extra>'
        });
      }
      
      // Set up plot layout
      const layout = {
        title: {
          text: 'Phonon Dispersion Relation',
          font: { size: 18, color: '#2c3e50' }
        },
        xaxis: { 
          title: 'Wave Vector Path',
          showgrid: true,
          gridcolor: '#e0e0e0',
          zeroline: false
        },
        yaxis: { 
          title: 'Frequency (THz)',
          showgrid: true,
          gridcolor: '#e0e0e0',
          zeroline: true,
          zerolinecolor: '#999',
          zerolinewidth: 1
        },
        plot_bgcolor: 'white',
        paper_bgcolor: 'white',
        margin: { l: 60, r: 40, t: 60, b: 60 },
        font: { family: 'Arial, sans-serif', size: 12 },
        hovermode: 'closest'
      };
      
      // Add high-symmetry point labels if available
      if (data.labels && data.label_positions) {
        layout.xaxis.tickvals = data.label_positions;
        layout.xaxis.ticktext = data.labels;
      }
      
      const config = {
        responsive: true,
        displayModeBar: true,
        displaylogo: false,
        modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d', 'autoScale2d']
      };
      
      // Create the plot
      Plotly.newPlot("phononPlot", traces, layout, config);
      
      document.getElementById("phononStatus").innerHTML = 
        `<div class="success">âœ“ Phonon dispersion loaded (${numModes} modes, ${data.qpoints.length} q-points)</div>`;
      
      console.log(`Phonon dispersion plotted successfully: ${numModes} modes`);
      
    })
    .catch(error => {
      console.error("Error loading phonon data:", error);
      document.getElementById("phononStatus").innerHTML = 
        `<div class="error">Error loading phonon_band.json: ${error.message}</div>`;
    });
}

// Initialize everything when page loads
document.addEventListener('DOMContentLoaded', function() {
  console.log("Page loaded, initializing components...");
  
  // Load components with proper error handling
  setTimeout(() => {
    load3DStructure();
    loadStructuralData();
    loadPhononData();
  }, 100);
});

// Handle window resize for responsive plots
window.addEventListener('resize', function() {
  if (document.getElementById('phononPlot') && phononData) {
    Plotly.Plots.resize('phononPlot');
  }
});

// Add debugging information
console.log("MAXene viewer script loaded. Waiting for DOM content...");
</script>
</body>
</html>
